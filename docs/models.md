# 并发模型

## 1. 线程模型

### 1.1 用户级线程
- 在用户空间实现
- 操作系统不可见
- 切换开销小
- 阻塞操作会阻塞所有线程

### 1.2 内核级线程
- 操作系统直接支持
- 每个线程是独立的调度单位
- 切换开销大
- 阻塞操作只阻塞当前线程

### 1.3 混合线程
- 结合用户级和内核级线程
- 用户线程映射到内核线程
- 灵活性和性能的平衡

## 2. 事件驱动模型

### 2.1 Reactor模式
- 单线程事件循环
- 非阻塞I/O操作
- 适合I/O密集型应用
- 示例：Node.js、Nginx

### 2.2 Proactor模式
- 异步I/O操作
- 操作系统完成I/O后通知应用
- 编程模型更复杂

## 3. Actor模型

### 3.1 核心概念
- Actor是基本计算单元
- 每个Actor有自己的状态
- Actor之间通过消息通信
- 没有共享内存

### 3.2 特点
- 强隔离性
- 位置透明性
- 容错性好
- 示例：Erlang、Akka

## 4. CSP模型（Communicating Sequential Processes）

### 4.1 核心概念
- 进程通过通道通信
- 通道是同步或异步的
- 进程可以组合
- 示例：Go语言

### 4.2 与Actor模型的区别
- CSP：通道是第一公民，进程匿名
- Actor：Actor是第一公民，通道隐含

## 5. 数据流模型

### 5.1 数据驱动计算
- 计算在数据就绪时触发
- 天然并行
- 适合流处理

### 5.2 实现方式
- 有向无环图（DAG）
- 数据流编程语言
- 示例：TensorFlow计算图

## 6. 软件事务内存（STM）

### 6.1 核心思想
- 将数据库事务概念引入内存操作
- 原子地执行一组内存操作
- 冲突时自动重试

### 6.2 优点
- 简化并发编程
- 避免死锁
- 示例：Clojure、Haskell

## 7. MapReduce模型

### 7.1 核心概念
- Map阶段：并行处理输入数据
- Shuffle阶段：数据重分区
- Reduce阶段：聚合结果

### 7.2 适用场景
- 大规模数据处理
- 批处理任务
- 示例：Hadoop、Spark

## 模型选择指南

| 模型 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| 线程模型 | CPU密集型任务 | 控制粒度细 | 同步复杂 |
| 事件驱动 | I/O密集型任务 | 高并发 | CPU密集型性能差 |
| Actor模型 | 分布式系统 | 容错性好 | 消息传递开销 |
| CSP模型 | 并发控制 | 清晰的数据流 | 通道管理复杂 |
| 数据流模型 | 流处理 | 天然并行 | 不适合通用计算 |
| STM | 共享内存访问 | 编程简单 | 性能开销 |
| MapReduce | 大数据处理 | 可扩展性好 | 延迟高 |

## 现代并发模型趋势

### 1. 协程（Coroutine）
- 用户态轻量级线程
- 协作式调度
- 示例：Kotlin协程、Python asyncio

### 2. 结构化并发
- 生命周期管理
- 错误传播
- 资源清理

### 3. 响应式编程
- 数据流和变化传播
- 声明式编程
- 示例：RxJava、Reactor