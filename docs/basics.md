# 并发编程基础概念

## 什么是并发？
并发是指多个任务在同一时间段内交替执行，通过时间片轮转的方式实现"同时"执行的效果。

## 核心概念

### 1. 进程 vs 线程
- **进程**：操作系统资源分配的基本单位，拥有独立的内存空间
- **线程**：CPU调度的基本单位，共享进程的内存空间

### 2. 并发 vs 并行
- **并发**：多个任务交替执行，宏观上看起来是同时的
- **并行**：多个任务真正同时执行，需要多核CPU支持

### 3. 同步 vs 异步
- **同步**：调用者等待被调用者返回结果
- **异步**：调用者不等待，被调用者完成后通过回调等方式通知

### 4. 阻塞 vs 非阻塞
- **阻塞**：调用者等待操作完成
- **非阻塞**：调用者立即返回，不等待操作完成

## 并发带来的挑战

### 1. 竞态条件（Race Condition）
多个线程/进程同时访问共享资源，执行结果依赖于执行的时序。

### 2. 死锁（Deadlock）
多个线程互相等待对方释放资源，导致所有线程都无法继续执行。

### 3. 活锁（Livelock）
线程不断改变状态以响应其他线程，但无法取得进展。

### 4. 饥饿（Starvation）
某个线程长期无法获得所需资源。

### 5. 内存可见性问题
一个线程对共享变量的修改，其他线程可能无法立即看到。

## 并发编程的基本原则

1. **最小化共享状态**：减少需要同步的共享数据
2. **使用不可变对象**：避免状态变化带来的并发问题
3. **线程安全设计**：确保对象在多线程环境下正确工作
4. **避免过度同步**：只在必要时进行同步
5. **优先使用高级抽象**：使用并发框架而非直接操作线程

## 并发级别

### 1. 无并发
- 单线程顺序执行
- 简单但无法充分利用多核CPU

### 2. 粗粒度并发
- 少量线程执行大任务
- 同步开销小，但并发度低

### 3. 细粒度并发
- 大量线程执行小任务
- 并发度高，但同步开销大

### 4. 数据并行
- 相同操作应用于不同数据
- 适合SIMD架构

### 5. 任务并行
- 不同任务并行执行
- 适合MIMD架构